import icaro.infraestructura.recursosOrganizacion.recursoTrazas.ItfUsoRecursoTrazas;
import icaro.infraestructura.recursosOrganizacion.recursoTrazas.imp.componentes.InfoTraza;
import icaro.infraestructura.entidadesBasicas.procesadorCognitivo.*;
import icaro.infraestructura.patronAgenteCognitivo.procesadorObjetivos.gestorTareas.ItfGestorTareas;
import icaro.infraestructura.entidadesBasicas.PerformativaUsuario;
import icaro.infraestructura.entidadesBasicas.comunicacion.*;
import icaro.aplicaciones.agentes.AgenteAplicacionMinions.objetivos.*;
import icaro.aplicaciones.informacion.gestionCitas.*;
import icaro.aplicaciones.informacion.minions.*;
import icaro.aplicaciones.agentes.AgenteAplicacionMinions.tareas.*;
import icaro.infraestructura.entidadesBasicas.informes.*;
import java.util.*;

global ItfGestorTareas gestorTareas;
global ItfUsoRecursoTrazas recursoTrazas;
global String agentId;

rule "Creacion de los objectivos iniciales"
when 
then 
TareaSincrona tarea = gestorTareas.crearTareaSincrona(InicializarInfoWorkMem.class);
    tarea.ejecutar();
recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName()); 
end
// =======================================================================
//Reglas de focalizacion de objetivos.
rule "Regla de focalizacion de explorar"
 when
    f:Focus(foco == null )
    obj:Explorar()
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

// =======================================================================
//Reglas de generacion de objetivos.
rule "Regla de generacion de explorar"
 when
    f:Focus(foco == null)
    notif:Notificacion(identInterlc:identNotificador, tipoNotificacion==VocabularioControlMinions.NombreTipoNoticacionExplorar)
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Generar objetivo de exploracion",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(GenerarObjetivoExploracion.class);
 	tarea.ejecutar(notif);
 	retract(notif);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// =============================== exploracion =======================================
// Reclas de realizacion de eploracion
rule "Regla de realizacion de explorar"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Moverse ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(SeleccionarZonaExploracion.class);
 	tarea.ejecutar(zon);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion del movimiento y observacion"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
    event:GameEvent(name=="event finished")
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Observar ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar();
 	retract(event);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion de la observacion"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
    event:GameEvent(name=="observation finished")
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : almacenar informacion nueva ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(AlmacenarInformacionNueva.class);
 	tarea.ejecutar();
 	retract(event);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= MOVIMIENTO ==============================

rule "AUX generar alcanzar posición test"
 when
 	event:GameEvent(name.equals("AlcanzarPosicion"))
 	mi:MinionInfo()
 	eval ( event.getParameter("entity").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new AlcanzarPosicion((Coord) event.getParameter("cell"), (Integer) event.getParameter("distance"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
 then
    obj.setState(Objetivo.SOLVING);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Moverse.class);
 	tarea.ejecutar(mi, mc, obj.getCoord(), obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(obj);
end

rule "Regla de consecucion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval( StaticUtil.EventMoveCheck(report,mi) )
 then
  	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Evaluar el resultado del movimiento ",InfoTraza.NivelTraza.debug));
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EvaluaResultadoMovimiento.class);
 	tarea.ejecutar(obj, mi, report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion correcta de alcanzar posicion"
 when
    alcanzar:AlcanzarPosicion(state==Objetivo.SOLVED)
    f:Focus(foco==alcanzar)
    not ( exists ( ArbolObjetivos.NodoArbol(getSubobjetivo() == alcanzar) ) ) 
 then
    f.setFoco(alcanzar.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    update(f);
    retract(alcanzar);
end

rule "Regla de finalizacion correcta de alcanzar posicion con nodo"
 when
    obj:AlcanzarPosicion(state==Objetivo.SOLVED)
    obj2:RealizarArbol()
    f:Focus(foco==obj)
   	nodo:ArbolObjetivos.NodoArbol()
   	eval ( nodo.getSubobjetivo() == obj )
 then
    f.setFoco(obj2);
    nodo.setSubobjetivo(obj);
    update(nodo);
    update(f);
    retract(obj);
    
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
end

rule "Regla de finalizacion incorrecta de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.FAILED)
    f:Focus(foco==obj)
 then
 	// TODO resolver esta regla al darse error
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= obtener OBJETO =============================

rule "Regla de pendiente de obtener objeto"
 when
    obj:ObtenerObjeto(state==Objetivo.PENDING)
    f:Focus(foco==obj)
 then
    obj.setSolving();
    update(obj);

    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de resolucion de obtener objeto"
 when
    obj:ObtenerObjeto(state==Objetivo.SOLVING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.heObservado == false )
 then
    Subobjetivo ap = new ObservarEntorno();
    ap.setParent(obj);
    
    insert(ap);
    obj.heObservado = true;
    update(obj);

    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de resolucion de obtener objeto tras observar"
salience -5
 when
    obj:ObtenerObjeto(state==Objetivo.SOLVING)
    obj2:RealizarArbol()
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.heObservado )
 then

	boolean encontrado = false;
	
// Lo busco en mis manos
    for(ItemData item : mi.getUnavailableItems()){
    	// Lo tengo en mis manos
    	if(item.getName().equals(obj.objeto) && mi.getInstanceId() == item.get_minionID()){
    		encontrado = true;
    		break;
    	}
    }
    
    if(!encontrado){
// Lo busco a distancia <= 1 de mi
		for(ItemData item : mi.getAvailableItems()){
			if(item.getName().equals(obj.objeto) && item.getCoords().distanceTo(mi.getCoords()) <= 1){
	    		encontrado = true;
	    		break;
	    	}
		}
    }
    
    if(encontrado){
    	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," RESUELTO :D:D:D");
    	obj.setSolved();
    }else{
    	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," FALLIDO :C");
    	obj.setFailed();
    }
    
    update(obj);

    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Post-regla de obtener objeto con arbol sin entrega"
 when
    obj:ObtenerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    
    eval ( obj.getParent() == null || ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) 
 then
    
    RecogerObjeto recoger = new RecogerObjeto(obj.getObjetoObtenido());
    recoger.setParent(obj2);
    f.setFoco(recoger);
    
    
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
    insert(recoger);
    update(f);
end

rule "Post-regla de obtener objeto con arbol con entrega, solicitud de coordenadas"
 when
    obj:ObtenerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    not ( eval ( obj.getParent() == null || ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
    not ( exists ( InformeDeTarea(identTarea.equalsIgnoreCase("DevolverSolicitudCoordenadas") ) ) )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EnviarPeticionCoordenadas.class);
 	tarea.ejecutar(obj);
end

rule "Post-regla de obtener objeto con arbol con entrega, coordenadas recibidas"
 when
    obj:ObtenerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    infoDeTarea : InformeDeTarea(identTarea.equalsIgnoreCase("DevolverPeticionCoordenadas") )
    not ( eval ( obj.getParent() == null ||  ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
 then
    Coord destinatario = (Coord) infoDeTarea.getContenidoInforme();
    
    Subobjetivo depositarObjeto = new DepositarObjeto(obj.getObjetoObtenido(), destinatario);
    f.setFoco(depositarObjeto);
    
    depositarObjeto.setParent(obj2);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    
    insert(depositarObjeto);
    update(f);
    retract(obj);
end


// ========================= FABRICAR OBJETO =============================

rule "Regla de pendiente de fabricar objeto"
 when
    obj:FabricarObjeto(state==Objetivo.PENDING)
    f:Focus(foco==obj)
 then
    obj.setSolving();
    update(obj);

    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de resolucion de fabricar objeto"
 when
    obj:FabricarObjeto(state==Objetivo.SOLVING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.heObservado == false )
 then
    Subobjetivo ap = new ObservarEntorno();
    ap.setParent(obj);
    
    insert(ap);
    obj.heObservado = true;
    update(obj);

    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de resolucion de fabricar objeto tras observar"
salience -5
 when
    obj:FabricarObjeto(state==Objetivo.SOLVING)
    obj2:RealizarArbol()
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    nodoArbol : NodoArbol(getSubobjetivo() == obj)
    eval ( obj.heObservado && !obj.esperandoReporteUso)
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Fabricar.class);
 	tarea.ejecutar(mi, mc, nodoArbol);
end

rule "Regla de resolucion de fabricar objeto tras el reporte del uso"
 when
    obj:FabricarObjeto(state==Objetivo.SOLVING)
    obj2:RealizarArbol()
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    nodoArbol : NodoArbol(getSubobjetivo() == obj)
    gameEvent : GameEvent( name.equalsIgnoreCase("UseReport")  && getParameter("minion_id") ==  mi.getInstanceId() )
    eval ( obj.esperandoReporteUso )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    
    ItemData item = obj.buscaObjetoResultante(gameEvent);
    
// Importante decirle cual es el item que se ha obtenido, a posteriori
    if(obj.getParent() instanceof ObtenerObjeto){
    	ObtenerObjeto parent = (ObtenerObjeto)obj.getParent();
    	parent.setObjetoObtenido(item);
    }
    
    RecogerObjeto recoger = new RecogerObjeto(item);
    recoger.setParent(obj);
    
    obj.setSolved();
    f.setFoco(recoger);
    insert(recoger);
    update(f);
    update(obj);
    
end

rule "Post-regla de fabricar objeto con arbol sin entrega"
 when
    obj:FabricarObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    
    eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) 
 then
    f.setFoco(obj2);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
    update(f);
end

rule "Post-regla de fabricar objeto con arbol con entrega, solicitud de coordenadas"
 when
    obj:FabricarObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    not ( eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
    not ( exists ( InformeDeTarea(identTarea.equalsIgnoreCase("DevolverSolicitudCoordenadas") ) ) )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EnviarPeticionCoordenadas.class);
 	tarea.ejecutar(obj);
end

rule "Post-regla de fabricar objeto con arbol con entrega, coordenadas recibidas"
 when
    obj:FabricarObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    infoDeTarea : InformeDeTarea(identTarea.equalsIgnoreCase("DevolverPeticionCoordenadas") )
    not ( eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
 then
  	Coord destinatario = (Coord) infoDeTarea.getContenidoInforme();
    
    Subobjetivo depositarObjeto = new DepositarObjeto(((ObtenerObjeto)obj.getParent()).getObjetoObtenido(), destinatario);
    f.setFoco(depositarObjeto);
    
    depositarObjeto.setParent(obj2);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    
    insert(depositarObjeto);
    update(f);
    retract(obj);
end

// ========================= recoger OBJETO ==============================

rule "AUX generar recoger objeto test"
 when
 	event:GameEvent(name.equals("RecogerObjeto"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new RecogerObjeto((ItemData) event.getParameter("item"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de recoger objeto cercano"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.getItem().canPick(mi.getCoords()) && mi.getMaxFuerza() >= obj.getItem().getPeso()  )
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Recoger.class);
 	tarea.ejecutar(mi, mc, obj.getItem());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
     recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de resolucion de recoger objeto cercano pesado"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.getItem().canPick(mi.getCoords()) && mi.getMaxFuerza() < obj.getItem().getPeso() )
 then
    obj.setSolved();
    update(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de resolucion de recoger objeto lejano"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    not ( eval ( obj.getItem().canPick(mi.getCoords()) ) )
 then
    Subobjetivo ap = new AlcanzarPosicion( obj.getItem().getCoords(), 1);
    ap.setParent(obj);
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de consecucion de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval(((GameEvent)report.getParameter("event")).getName().equals("pick item") && ((GameEvent)report.getParameter("event")).getParameter("minion_id").equals(mi.getInstanceId()) )
 then
  	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Evaluar el resultado de recoger objeto ",InfoTraza.NivelTraza.debug));
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EvaluaResultadoRecoger.class);
 	tarea.ejecutar(obj, mi, report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion correcta de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
    not ( exists ( ArbolObjetivos.NodoArbol( getSubobjetivo() == obj ) ) )
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
    update(f);
end

rule "Post-regla de recoger objeto con arbol sin entrega"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    nodoArbol : ArbolObjetivos.NodoArbol( getSubobjetivo() == obj );
    eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId)  )
 then
    f.setFoco(obj2);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());

// Importante decirle cual es el item que se ha obtenido, a posteriori
    if(obj.getParent() != null && obj.getParent() instanceof ObtenerObjeto){
    	ObtenerObjeto parent = (ObtenerObjeto)obj.getParent();
    	parent.setObjetoObtenido(obj.getItem());
    }
    
    retract(obj);
    update(f);
end

rule "Post-regla de recoger objeto con arbol con entrega, solicitud de coordenadas"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    nodoArbol : ArbolObjetivos.NodoArbol( getSubobjetivo() == obj );
    not ( eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
    not ( exists ( InformeDeTarea(identTarea.equalsIgnoreCase("DevolverSolicitudCoordenadas") ) ) )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EnviarPeticionCoordenadas.class);
 	tarea.ejecutar(obj);
end

rule "Post-regla de recoger objeto con arbol con entrega, coordenadas recibidas"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVED)
    obj2 : RealizarArbol() 
    f:Focus(foco==obj)
    mi : MinionInfo()
    nodoArbol : ArbolObjetivos.NodoArbol( getSubobjetivo() == obj );
    infoDeTarea : InformeDeTarea(identTarea.equalsIgnoreCase("DevolverPeticionCoordenadas") )
    not ( eval ( ((Subobjetivo)obj.getParent()).getOwner().equalsIgnoreCase(agentId) ) )
 then
    Coord destinatario = (Coord) infoDeTarea.getContenidoInforme();
    
    Subobjetivo depositarObjeto = new DepositarObjeto(obj.getItem(), destinatario);
    f.setFoco(depositarObjeto);
    
    depositarObjeto.setParent(obj2);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    
// Importante decirle cual es el item que se ha obtenido, a posteriori
    if(obj.getParent() instanceof ObtenerObjeto){
    	ObtenerObjeto parent = (ObtenerObjeto)obj.getParent();
    	parent.setObjetoObtenido(obj.getItem());
    }
    
    insert(depositarObjeto);
    update(f);
    retract(obj);
end

rule "Regla de finalizacion incorrecta de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.FAILED)
    f:Focus(foco==obj)
    not ( exists ( ResolverArbol() ) )
 then
 	// TODO resolver esta regla al darse error
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= DEPOSITAR OBJETO ==============================

rule "AUX generar depositar objeto test"
 when
 	event:GameEvent(name.equals("DepositarObjeto"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new DepositarObjeto((ItemData) event.getParameter("item"), (Coord) event.getParameter("destination"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de depositar objeto cercano"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.isNear(mi.getCoords()) )
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Depositar.class);
 	tarea.ejecutar(mi, mc, obj.getItem(), obj.getDestination());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
     recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de resolucion de depositar objeto lejano"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    not ( eval ( obj.isNear(mi.getCoords()) ) )
 then
    Subobjetivo ap = new AlcanzarPosicion( obj.getDestination(), 1);
    ap.setParent(obj);
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de consecucion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval(((GameEvent)report.getParameter("event")).getName().equals("drop item") && ((GameEvent)report.getParameter("event")).getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    obj.setSolved();
    update(obj);
end

rule "Regla de finalizacion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
    update(f);
end

// ========================= OBSERVAR ENTORNO ==============================

rule "AUX generar observar entorno"
 when
 	event:GameEvent(name.equals("ObservarEntorno"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new ObservarEntorno();
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar(mi,mc);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de consecucion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("observereport"))
    mi:MinionInfo()
    eval ( report.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(AlmacenarObservado.class);
 	tarea.ejecutar(mi,report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
    obj.setState(Objetivo.SOLVED);
    update(obj);
end

rule "Regla de finalizacion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
    update(f);
end

// ========================= Obtencion de un objeto ==============================

/*rule "Regla de focalizacion de obtener objeto"
 when
    obj:ObtenerObjeto(state==Objetivo.PENDING)
    f:Focus(foco==null)
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end


rule "Regla de resolucion de ObtenerObjeto si conozco informacion del objeto"
 when
    obj:ObtenerObjeto(o:objeto,state==Objetivo.PENDING)
    f:Focus(foco==obj)
    i:Item(name==o)
 then
    f.setFoco(obj);
    obj.setState(Objetivo.SOLVING);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Moverse.class);
 	tarea.ejecutar(i, obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
    update(obj);
end

rule "Regla de resolucion de ObtenerObjeto si no conozco informacion"
 when
    obj:ObtenerObjeto(o:objeto,state==Objetivo.PENDING)
    f:Focus(foco == obj)
    not ( Item(name==o) )
 then
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar(i, obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end*/

rule "Actualiza el estado del minion con alta prioridad"
salience +10
when
	event:GameEvent(name.equalsIgnoreCase("update minion"))
	mi:MinionInfo()
	eval ( ((MinionInfo)event.getParameter("minion")).getInstanceId() == mi.getInstanceId() )
then
	retract(mi);
	insert((MinionInfo)event.getParameter("minion"));
	retract(event);
end

rule "Limpieza de evento en memoria con baja prioridad"
salience -10 
when
	event:GameEvent()
then
	retract(event);
end

// ####################### Proceso de resolución de objetivos por equipos #############################

// ========================= Descubrimiento y planificación de la tarea ==============================

rule "Descubre objetivo propuesto"
when
	mc:MinionContext()
	obj:Subobjetivo()
	f:Focus(foco==null)
	eval(obj.getParent() == null)
	not ( exists ( ArbolObjetivos() ) )
then
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(CrearArbolObjetivos.class);
 	tarea.ejecutar(mc, obj);
	
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================== Gestion de la lista de integrantes =====================================

rule "Acepta solicitud de participacion"
when
	f:Focus(foco==null)
	event:GameEvent(name.equalsIgnoreCase("solicitud participacion"))
then
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(AceptarSolicitudParticipacion.class);
 	tarea.ejecutar(f, event);
 	
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Mezcla listas"
when
	obj:CrearListaIntegrantes(state == Objetivo.SOLVING)
	f:Focus(foco==obj)
	lista1:ArbolObjetivos.ListaIntegrantes()
	lista2:ArbolObjetivos.ListaIntegrantes()
	eval (lista1 != lista2)
then
// Intento la mezcla y si hay cambios reenvío
	if(lista1.mezclarCon(lista2)){
		lista1.reenviarATodosSalvoA(agentId);
		
		//La clono para asegurarme de que la isntancia cambia
		obj.lista = lista1.clona();
		retract(lista1);
		insert(obj.lista);
	}else{
		// Me guardo la lista actual, para cuando salte el timeout
		obj.lista = lista1;
	}
	
// En cualquier caso inicio el timeout
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(ComenzarTimeoutListaIntegrantes.class);
    tarea.ejecutar(obj, lista1);
	
// Me cargo la que es antigua
 	
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	retract(lista2);
end

rule "Gestion de informe de timeout correcto"
when
	f : Focus(obj:foco)
	infoTarea : InformeDeTarea(identTarea.equalsIgnoreCase("ComenzarTimeoutListaIntegrantes"))
	arbol : ArbolObjetivos()
// si aún estoy creando la lista
	eval ( obj.getgoalId().equals("CrearListaIntegrantes") && obj.getState() == Objetivo.SOLVING 
// Si mi lista no ha cambiado desde el inicio del timeout entonces doy por finalizado el objetivo
		&& ((CrearListaIntegrantes) obj).lista.equals(infoTarea.contenidoInforme) )
then
// Este método solo afecta la primera vez.
	arbol.setListaIntegrantes(((CrearListaIntegrantes) obj).lista);
	update(arbol);
	arbol.enviarArbolActualizado(agentId); 

// Finalmente me deshago del informe
	retract(infoTarea);
	
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Eliminar informe timeout con baja prioridad"
salience -10
when
	infoTarea : InformeDeTarea(identTarea.equalsIgnoreCase("ComenzarTimeoutListaIntegrantes"))
then
	retract(infoTarea);
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Finalizacion del objetivo crear lista de integrantes"
when
	obj:CrearListaIntegrantes(state == Objetivo.SOLVING)
	f:Focus(foco == obj)
	arbol:ArbolObjetivos(listaIntegrantes != null)
then
// Al terminar se pasará al objetivo ResolverArbol
	Objetivo o = new ResolverArbol();
	o.setSolving();
	f.setFoco(o);
	
	insert(o);
	update(f);   
	retract(obj);
	
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Limpieza de listas en memoria con prioridad"
salience 10
when
	not ( exists ( CrearListaIntegrantes() ) )
	lista:ArbolObjetivos.ListaIntegrantes()
then
	retract(lista);
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Actualización del arbol local con prioridad desde evento"
salience 10
when
	arbol:ArbolObjetivos()
	event:GameEvent(name.equalsIgnoreCase("ActualizaArbol"))
then
	retract(arbol);
	insert(event.getParameter("arbol"));
	retract(event);		
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Actualización del arbol local con prioridad"
salience 10
when
	arbol1:ArbolObjetivos()
	arbol2:ArbolObjetivos()
	eval ( !arbol1.equals(arbol2) )
then
	ArbolObjetivos masActualizado = ArbolObjetivos.SeleccionaArbolMasActualizado(arbol1,arbol2);
	if(masActualizado == arbol1){
		retract(arbol2);
	}else if( masActualizado == arbol2){
		retract(arbol1);
	}
		
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


// ============================ ENCUESTAS ===========================

rule "Iniciar encuestas"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	arbol : ArbolObjetivos()
	eval ( arbol.getListaIntegrantes().getJefeEncuestas().equals(agentId) && arbol.getNextPendingNode() != null ) 
	not ( exists ( ListaEncuestas() ) ) 
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	ArbolObjetivos.NodoArbol next = arbol.getNextPendingNode();
	ListaEncuestas listaEncuestas = new ListaEncuestas(next, arbol.getListaIntegrantes());
	insert(listaEncuestas);
	arbol.enviarEncuestas(agentId, arbol.getNextPendingNode());
end

// **************************  VALORACIONES DE ENCUESTAS *********************************

rule "Procesar encuesta alcanzar posicion"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo( encuestado.equals(agentId) && resuelta == false )
	eval ( encuesta.nodo.getSubobjetivo() instanceof AlcanzarPosicion )
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación por cercania
	AlcanzarPosicion ap = (AlcanzarPosicion) encuesta.nodo.getSubobjetivo();
	encuesta.estimacion = ap.getCoord().distanceTo(mi.getCoords());
	encuesta.setResuelta();
	update(encuesta);
end

rule "Procesar encuesta obtener objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo( encuestado.equals(agentId) && resuelta == false )
	eval ( encuesta.nodo.getSubobjetivo() instanceof ObtenerObjeto )
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación por cercania
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(ValorarEncuestaObtenerObjeto.class);
	tarea.ejecutar(encuesta);
end

rule "Procesar encuesta recoger objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo( encuestado.equals(agentId) && resuelta == false )
	eval ( encuesta.nodo.getSubobjetivo() instanceof RecogerObjeto )
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación por cercania
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(ValorarEncuestaRecogerObjeto.class);
	tarea.ejecutar(mi, encuesta);
end

rule "Procesar encuesta fabricar objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo( encuestado.equals(agentId) && resuelta == false )
	eval ( encuesta.nodo.getSubobjetivo() instanceof AlcanzarPosicion )
	conocimientosFabricacion : ConocimientosFabricacion()
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación por cercania
	FabricarObjeto fo = (FabricarObjeto) encuesta.nodo.getSubobjetivo();
	
	List<String> noValidos = new java.util.ArrayList<String>();
	for(icaro.aplicaciones.informacion.minions.ArbolObjetivos.NodoArbol hijo : encuesta.nodo.getHijos() ){
		if(hijo.getEstado() == ArbolObjetivos.EstadoNodo.Irresoluble && hijo.getSubobjetivo() instanceof ObtenerObjeto){
			ObtenerObjeto o = (ObtenerObjeto)hijo.getSubobjetivo();
			noValidos.add(o.objeto);
		}
	}
	
	String[] combinacion = conocimientosFabricacion.getCombinacion(fo.objeto, noValidos);
	if(combinacion != null){
		encuesta.estimacion = 1;
	}else{
		encuesta.estimacion = -1;
	}
	
	encuesta.setResuelta();
	update(encuesta);
end

rule "Procesar encuesta desconocida"
salience -1
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo( encuestado.equals(agentId) && resuelta == false )
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación de imposibilidad
	encuesta.estimacion = mi.getInstanceId();
	encuesta.setResuelta();
	update(encuesta);
end

// ************************ FIN VALORACIONES DE ENCUESTAS *********************************

rule "Devolver encuesta cuando esté marcada como resuelta"
salience -10
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	encuesta : EncuestaNodo(resuelta == true)
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(DevolverEncuesta.class);
    tarea.ejecutar(encuesta);
end

rule "Procesar encuesta resuelta recibida"
salience -20
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	listaEncuestas : ListaEncuestas( )
	encuesta : EncuestaNodo(resuelta == true)
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	listaEncuestas.addEncuesta(encuesta);
	retract(encuesta);
	update(listaEncuestas);
end

rule "Finalizar encuestas"
salience -30
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	listaEncuestas : ListaEncuestas( )
	arbol : ArbolObjetivos()
	eval ( listaEncuestas.contieneTodas() && ! listaEncuestas.isEsperandoResolucion() )  
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," Revisando encuestas de: " + listaEncuestas.getNodo().getSubobjetivo().toString());

	EncuestaNodo encuesta = listaEncuestas.getMejorEncuesta();
	if(encuesta == null){
		recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," No hay ninguna encuesta para resolver el nodo.");
		if(listaEncuestas.getNodo().getSubobjetivo().esAtomico()){
			listaEncuestas.getNodo().setEstado(ArbolObjetivos.EstadoNodo.Irresoluble);
			retract(listaEncuestas);
		}else{
			recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," Voy a preguntar al usuario ");
			listaEncuestas.setEsperandoResolucion(true);
			arbol.solicitarSolucionAlUsuario(listaEncuestas.getNodo());
		}
	}else{
		listaEncuestas.setEsperandoResolucion(true);
		recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Solicitando resolucion del nodo: " + encuesta.toString());
		TareaSincrona tarea = gestorTareas.crearTareaSincrona(SolicitarResolucionNodo.class);
		tarea.ejecutar(encuesta);
	}
	
end

// ============================== Reglas de resolucion de nodo ===================================

rule "Resolver nodo atomico con baja prioridad"
salience -5
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	peticion : PeticionResolucionNodo()
	eval ( peticion.getNodo().getSubobjetivo().esAtomico() && peticion.getNodo().getEstado() == ArbolObjetivos.EstadoNodo.Pendiente )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	peticion.getNodo().setNewOwner(agentId);
	peticion.getNodo().setEstado(ArbolObjetivos.EstadoNodo.Validado);
	update(peticion);
end


rule "Resolver nodo obtener objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	peticion : PeticionResolucionNodo()
	eval ( peticion.getNodo().getSubobjetivo() instanceof ObtenerObjeto && peticion.getNodo().getEstado() == ArbolObjetivos.EstadoNodo.Pendiente )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(ResolverPeticionObtenerObjeto.class);
	tarea.ejecutar(peticion);
end

rule "Resolver nodo recoger objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	peticion : PeticionResolucionNodo()
	mi : MinionInfo()
	eval ( peticion.getNodo().getSubobjetivo() instanceof RecogerObjeto && peticion.getNodo().getEstado() == ArbolObjetivos.EstadoNodo.Pendiente )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(ResolverPeticionRecogerObjeto.class);
	tarea.ejecutar(mi, peticion);
end


rule "Resolver nodo fabricar objeto"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	peticion : PeticionResolucionNodo()
	eval ( peticion.getNodo().getSubobjetivo() instanceof FabricarObjeto && peticion.getNodo().getEstado() == ArbolObjetivos.EstadoNodo.Pendiente )
	conocimientosFabricacion : ConocimientosFabricacion()
	mi : MinionInfo()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
// Estimación por cercania
	FabricarObjeto fo = (FabricarObjeto) peticion.getNodo().getSubobjetivo();
	
	List<String> noValidos = new java.util.ArrayList<String>();
	for(icaro.aplicaciones.informacion.minions.ArbolObjetivos.NodoArbol hijo : peticion.getNodo().getHijos() ){
		if(hijo.getEstado() == ArbolObjetivos.EstadoNodo.Irresoluble && hijo.getSubobjetivo() instanceof ObtenerObjeto){
			ObtenerObjeto o = (ObtenerObjeto)hijo.getSubobjetivo();
			noValidos.add(o.objeto);
		}
	}
	
	String[] combinacion = conocimientosFabricacion.getCombinacion(fo.objeto, noValidos);
	if(combinacion != null){
	    peticion.getNodo().setNewOwner(agentId);
	    if(peticion.getNodo().getPadre() != null)
            peticion.getNodo().getPadre().setNewOwner(agentId);
	    
		fo.combinacion = combinacion;
		for(String itemName : combinacion){
			Subobjetivo obtenerItem = new ObtenerObjeto(itemName);
			peticion.getNodo().addHijo(obtenerItem);
		}
	}else{
	
	}
	peticion.getNodo().setEstado(ArbolObjetivos.EstadoNodo.Resuelto);
	
	update(peticion);
end

rule "Devolver peticion nodo"
salience -10
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	peticion : PeticionResolucionNodo()
	eval ( peticion.getNodo().getEstado() != ArbolObjetivos.EstadoNodo.Pendiente )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(DevolverResolucionNodo.class);
	tarea.ejecutar(obj, peticion);
end

rule "Actualizar arbol despues de resolucion de nodo"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	infoTarea : InformeDeTarea(identTarea.equalsIgnoreCase("DevolverResolucionNodo"))
	listaEncuestas : ListaEncuestas()
	arbol : ArbolObjetivos()
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	
	retract(infoTarea);
	
	update(arbol);
	arbol.enviarArbolActualizado(agentId); 
	
	retract(listaEncuestas);
end


rule "Finalizar resolver arbol"
when
	obj : ResolverArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	arbol : ArbolObjetivos()
	eval ( arbol.getRoot().getEstado() == ArbolObjetivos.EstadoNodo.Validado ) 
// Para no acabar antes de tiempo
	not ( exists ( ListaEncuestas() ) ) 
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	Objetivo realizarArbol = new RealizarArbol();
	obj.setSolved();
	realizarArbol.setSolving();
	insert(realizarArbol);
	f.setFoco(realizarArbol);
	update(f);	
end

// =============================== Realización del arbol ==================================

rule "Extraer nodo del arbol si tengo nodo"
no-loop
when
	obj : RealizarArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	arbol : ArbolObjetivos()
	not ( exists ( ArbolObjetivos.NodoArbol() ) ) 
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	ArbolObjetivos.NodoArbol nodo = arbol.getNextUndoneNodeFor(agentId);
	if(nodo != null){
		insert(nodo);
	}else{
// En lo que a mi respecta...
		recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," No tengo nada que realizar, por mi he terminado.");
		obj.setSolved();
		f.setFoco(null);
		update(obj);
		update(f);
	}
end

rule "Extraer el objetivo del nodo y focalización cuando el nodo esta listo"
when
	obj : RealizarArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	arbol : ArbolObjetivos()
	nodo : ArbolObjetivos.NodoArbol()
	eval ( nodo.isReady() )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	f.setFoco(nodo.getSubobjetivo());
	insert(nodo.getSubobjetivo());
	update(f);
end

rule "Resolución del nodo al detectar subobjetivo SOLVED "
when
	obj : RealizarArbol(state == Objetivo.SOLVING)
	f : Focus(foco == obj) 
	arbol : ArbolObjetivos()
	nodo : ArbolObjetivos.NodoArbol()
	eval ( nodo.getSubobjetivo().getState() == Objetivo.SOLVED )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	nodo.setEstado(ArbolObjetivos.EstadoNodo.Realizado);

// Notificamos de nuestra finalización
	update(arbol);
	arbol.enviarArbolActualizado(agentId);
	
	retract(nodo);
end

rule "Devolver peticion coordenadas con prioridad"
salience +10
when
	peticionCoords : PeticionCoordenadas()
	mi : MinionInfo(  )
then
	recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
	TareaSincrona tarea = gestorTareas.crearTareaSincrona(DevolverPeticionCoordenadas.class);
	tarea.ejecutar(mi.getCoords(), peticionCoords);
end